# Сравнение языков PHP и C++: лексика, синтаксис и семантика
## Основные различия PHP и C++
**C++:**
1. Компилируемый язык, код преобразуется в машинный код
2. Типизация: Статическая строгая типизация, типы проверяются на этапе компиляции
3. Область применения: Системное программирование, игры, высокопроизводительные приложения
4. Ручное управление или умные указатели, нет сборщика мусора
5. Множественное наследование, передача объектов по значению
6. Высокая производительность, близкая к машинному коду
7. Безопасность: Ответственность на программисте (утечки памяти, buffer overflow)

**PHP:**
1. Интерпретируемый язык, выполняется через Zend Engine
2. Типизация: Динамическая слабая типизация, типы определяются в runtime
3. Область применения: Веб-разработка, серверная часть веб-приложений
4. Автоматическое управление памятью со сборщиком мусора
5. Одиночное наследование, объекты всегда по ссылке
6. Меньшая производительность, оптимизирован для веб-запросов
7. Безопасность: Защита на уровне движка (автоматическое управление памятью)

## 1. Синтаксис циклов, ветвлений и блоков кода
### Циклы:
**C++:**
1. Ключевые слова: for, while, do-while, range-based for (for (auto x : collection))
2. Операторы перехода: break, continue, goto, return
3. Возможность объявления переменных в условии цикла

**PHP:**
1. Ключевые слова for, while, do-while, foreach (для массивов и объектов) 
3. Операторы перехода: break, continue, return, goto
4. Альтернативный синтаксис: if(): ... endif;, foreach(): ... endforeach;, while(): ... endwhile;
```html
<?php for ($i = 0; $i < 10; $i++): ?>
    <div class="item-<?= $i ?>">Элемент <?= $i ?></div>
<?php endfor; ?>
```

### Ветвления:
**C++:**
1. Ключевые слова: if, else if, else, switch (только целочисленные типы)
2. Поддерживается тернарный оператор ? :
3. Возможность объявления переменных в условиях if (auto x = getValue())

**PHP:**
1. Ключевые слова if, elseif, else, switch (любые типы) 
3. Поддерживается тернарный оператор ? :
4. Поддерживается match (с PHP 8.0)

### Блоки кода:
**C++:**
1. Ограничиваются фигурными скобками {}

**PHP:**
1. Ограничиваются фигурными скобками {} 
2. Ограничиваются альтернативным синтаксисом с endif, endfor, endwhile

## 2. Объявление типов переменных и параметров
### Основной синтаксис
**PHP:**
1. Имя переменной всегда начинается со знака **доллара $**. 
2. Тип не указывается при объявлении, он определяется значением.

**C++:**
1. Имя переменной состоит только из букв, цифр и underscore, без специальных символов.
2. Тип переменной указывается обязательно перед её именем.

**Правила для имени переменных (общие для C++ и PHP):**
1. Может содержать буквы (a-z, A-Z), цифры (0-9) и underscore (_)
2. Не может начинаться с цифры
3. Регистрозависимость (X и x - разные переменные)
4. Не может совпадать с ключевыми словами языка
5. Не должен содержать пробелов или специальных символов (@, #, $ в C++, кроме $ в PHP)

### Типизация
**С++: Строгая типизация**
- Тип переменной фиксируется при компиляции и не может быть изменён.

**PHP: Динамическая типизация**
- Тип переменной может меняться во время выполнения.

### Область видимости
**PHP:**
1. Основные области видимости — глобальная и локальная (внутри функций). 
2. Для доступа к глобальной переменной внутри функции нужно использовать ключевое слово global или $GLOBALS.

**C++:**
1. Имеет сложную систему областей видимости: локальная, глобальная, классовая, пространства имён.
2. Простой доступ к глобальной переменной

### Константы
**PHP:**
1. Для констант используется функция define() или ключевое слово const. 
2. Тип не указывается.

**C++:**
1. Используется ключевое слово const. 
2. Тип указывается обязательно.

### Ссылки
**PHP:**
1. Для констант используется функция define() или ключевое слово const. 
2. Объявляются с помощью & перед названием переменной на которую создаётся ссылка.
```php
$original = 10;
$ref = &$original; // $ref - ссылка на $original
```

**C++:**
1. Ссылки — это псевдонимы для переменных. 
2. Объявляются с помощью & перед названием переменной.
3. Тип ссылки указывается обязательно.
```cpp
int original = 10;
int &ref = original; // ref - ссылка на original
```

### Указатели
**C++:**
1. Указатели объявляются с символом * после типа
2. Тип указателя указывается обязательно
3. Поддерживается арифметика указателей (инкремент, декремент)
4. Могут быть многоуровневые указатели (указатель на указатель)
5. Могут хранить адрес любой переменной или области памяти

**PHP:**
1. Классических указателей как в C++ не существует
2. Нет арифметики указателей и прямого управления памятью
3. Все переменные, содержащие объекты, работают по механизму ссылок

## 3. Набор типов данных
**C++:**
1. Целочисленные: int, short, long, long long, unsigned модификации, uint8_t, uint16_t, uint32_t, uint64_t, int8_t, int16_t, int32_t, int64_t, size_t
2. Вещественные: float, double, long double
3. Символьные: char, wchar_t, char16_t, char32_t
4. Логический: bool
5. Составные: массивы, структуры (struct), классы (class), объединения (union)
6. Указатели и ссылки: указатели (type*), ссылки (type&), умные указатели
7. Перечисления: enum, enum class
8. STL контейнеры: vector, string, map, set, list и другие

**PHP:**
1. Скалярные: int, float (дробные), string (строки), bool (логический)
2. Смешанные: array (массивы и словари), object (объекты)
3. Специальные: null, resource (внешние ресурсы)
4. Псевдотипы: callable (вызываемые), iterable (итерируемые)

## 4. Операторы
**C++:**
1. Арифметические: +, -, *, /, %, ++ (префиксный и постфиксный), -- (префиксный и постфиксный)
2. Операторы сравнения: ==, !=, <, >, <=, >=, <==>
3. Логические: &&, ||, !
4. Побитовые: & (И), | (ИЛИ), ^ (исключающее ИЛИ), ~ (НЕ), << (сдвиг влево), >> (сдвиг вправо)
5. Строковые: + для конкатенации (только с std::string)
6. Операторы присваивания: =, +=, -=, *=, /=, %=, &=, |=, ^=, <<=, >>=
7. Указатели и память: * (разыменование), & (взятие адреса), new, delete
8. Прочие: :: (область видимости), . (доступ к члену), -> (доступ через указатель)

**PHP:**
1. Арифметические: +, -, *, /, %, ** (возведение в степень), ++ (префиксный и постфиксный), -- (префиксный и постфиксный)
2. Операторы сравнения: ==, !=, <>, ===, !==, <, >, <=, >=, <=> (spaceship)
3. Логические: and, or, xor, &&, ||, !
4. Побитовые: & (И), | (ИЛИ), ^ (исключающее ИЛИ), ~ (НЕ), << (сдвиг влево), >> (сдвиг вправо)
5. Строковые: . для конкатенации, .= для присваивания с конкатенацией
6. Операторы присваивания: =, +=, -=, *=, /=, %=, **=, .=, &=, |=, ^=, <<=, >>=
7. Операторы работы с типами: instanceof, ?-> (nullsafe)
8. Прочие: @ (подавление ошибок), => (в массивах), ?? (null coalescing)

## 5. Пользовательские функции
**C++:**
1. Строгая типизация, обязательное указание типа возвращаемого значения и типов параметров
2. Передача параметров по значению, по ссылке (&), по указателю (*), константные ссылки (const&)
3. Возврат по значению, по ссылке, по указателю
4. Перегрузка функций: поддерживается (функции с одинаковым именем но разными параметрами)
5. Можно указать параметры по умолчанию
6. Поддерживаются шаблоны функций
7. Поддерживаются указатели на функции
8. Поддерживаются лямда-функции с захватом переменных
9. Массивы всегда передаются в функции, как указатели на первый элемент

**PHP:**
1. Слабая типизация, объявление типов параметров и возвращаемого значения опционально
2. Передача параметров по значению, по ссылке (с модификатором & перед параметром)
3. Возврат по значению, возврат по ссылке возможен с модификатором &
4. Перегрузка функций: не поддерживается
5. Можно указать параметры по умолчанию
6. Type hints: поддерживаются для объектов, массивов, callable, встроенных типов
7. Поддерживаются анонимные функции с использованием use для захвата переменных
8. Объекты всегда передаются по ссылке неявно, без использования &;

## 6. Пользовательские структуры/классы
**C++:**
1. Две формы: struct (по умолчанию public наследование) и class (по умолчанию private наследование)
2. Модификаторы доступа: public, private, protected указывается отдельно деля класс на блоки по модификаторам доступа
3. Поддерживается множественное наследование поддерживается
4. Передача объектов: по умолчанию передаются по значению (копирование)
5. Поддерживаются статические методы и переменные класса
6. Управление памятью: ручное с помощью new/delete
7. Дружественные функции: механизм friend для доступа к private членам
8. Виртуальные функции: полиморфизм через virtual и таблицу виртуальных методов
9. Можно объявить конструктор копирования, перемещения
10. Поддерживаются шаблоны классов

**PHP:**
1. Единственная форма: только class
2. Модификаторы доступа: public, private, protected указывается перед переменной/функцией/константой
3. Поддерживается только одиночное наследование
4. Передача объектов: всегда по ссылке
5. Поддерживаются статические методы и свойства
6. Управление памятью: автоматическое с помощью сборщика мусора
7. Позволяет указывать readonly class или readonly поля

## 7. Управление памятью
**C++:**
1. Ручное управление: прямое выделение (new, new[]) и освобождение (delete, delete[]) памяти
2. Автоматическое хранение: локальные переменные уничтожаются при выходе из области видимости
3. Умные указатели: std::unique_ptr, std::shared_ptr, std::weak_ptr для автоматического управления
4. Сборка мусора: отсутствует в стандарте, ответственность за память лежит на программисте
5. Конструкторы/деструкторы: явное управление временем жизни объектов
6. Утечки памяти: возможны при неправильном использовании указателей

**PHP:**
1. Нет ручного управления: отсутствуют операторы типа new/delete из C++
2. Автоматическое управление: сборщик мусора (Zend Engine) автоматически освобождает неиспользуемую память
3. Автоматическое уничтожение: объекты уничтожаются когда на них нет ссылок
4. Циклический сборщик: обнаружение и удаление циклических ссылок
5. Счетчик ссылок: механизм для отслеживания используемых переменных
6. Простое создание объектов: new ClassName() без необходимости ручного освобождения

## 8. Обработка ошибок
**C++:**
1. Механизм исключений: try/catch/throw с поддержкой разных типов исключений
2. Стандартные исключения: std::exception и его производные (runtime_error, logic_error и др.)
3. Функции noexcept: гарантия отсутствия исключений

**PHP:**
1. Механизм исключений: try/catch/finally, 
2. Наследование от Exception класса
3. Простота использования: автоматическое логирование, гибкая обработка разных типов ошибок

#### C++ (исключения)
```cpp
    try {
        if (x == 0) {
            throw runtime_error("Деление на ноль");
        }
        result = 100 / x;
    } catch (const exception& e) {
        std::cout << "Ошибка: " << e.what() << std::endl;
    }
```
#### PHP (исключения + традиционные ошибки)
```php
    try {
        if ($x == 0) {
            throw new Exception("Деление на ноль");
        }
        $result = 100 / $x;
    } catch (Exception $e) {
        echo "Ошибка: " . $e->getMessage();
    }
```



<!-- Почему так сложилось C++ и PHP похожи? -->