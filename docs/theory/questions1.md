# Вопросы про компиляторы

## 1. По какому алгоритму сделан парсер в clang и почему

**Алгоритм:** Clang использует **рукописный (hand-written) рекурсивный нисходящий парсер (recursive descent parser)**.

### Почему именно этот подход: детальный анализ

#### 1. Специфика языка C++ — контекстно-зависимая грамматика

C++ имеет **контекстно-зависимую грамматику**, которая не может быть выражена в форматах, подходящих для генераторов парсеров (LALR, LR). Классические проблемы:

- **Most Vexing Parse**: `T(x)` может быть как объявлением переменной, так и приведением типа
- **Зависимость от контекста**: `A * B;` может быть умножением или объявлением указателя, в зависимости от того, является ли `A` типом
- **Template parsing**: `vector<vector<int>>` исторически требовал пробела `> >`, а парсинг шаблонов требует произвольного lookahead
- **Typedef vs variable**: невозможно определить синтаксически без информации о символах

**Решение:** Рукописный парсер позволяет во время парсинга обращаться к таблице символов и принимать решения на основе контекста.

#### 2. Качество диагностики ошибок

Одна из главных целей Clang — **выдавать понятные сообщения об ошибках**.

**Проблема с генераторами парсеров:**
- LALR/LR парсеры выдают сообщения типа "unexpected token ';' at state 347"
- Они не знают о намерениях программиста
- Трудно предоставить контекстную информацию и подсказки (fix-it hints)

**Преимущества рукописного парсера:**
```cpp
// Clang может распознать это как забытую точку с запятой:
int x = 5
int y = 10;
// error: expected ';' after expression
//        int x = 5
//                 ^
//                 ;
```

- Можно написать специализированную логику для распространенных ошибок
- Возможность выдавать контекстные подсказки: "did you mean", "note: to match this '('"
- Можно анализировать намерения программиста

#### 3. Восстановление после ошибок (Error Recovery)

Качественное восстановление после ошибок критично для IDE и инкрементальной компиляции.

**Рукописный парсер позволяет:**
- Пропустить некорректную часть кода и продолжить парсинг
- Найти несколько ошибок за один проход
- Построить частичное AST даже для некорректного кода (важно для автодополнения в IDE)
- Реализовать эвристики для синхронизации (например, поиск следующей точки с запятой или закрывающей скобки)

**Генераторы парсеров:**
- Обычно останавливаются на первой ошибке
- Восстановление после ошибок в LALR парсерах очень сложно и ограничено

#### 4. Тесная интеграция с семантическим анализом

В Clang **парсинг и семантический анализ выполняются одновременно**.

**Архитектура:**
```
Parser → вызывает → Sema (Semantic Analysis) → строит → AST
```

**Зачем это нужно:**
- Для разрешения неоднозначностей C++ нужна информация о типах
- Построение таблицы символов во время парсинга
- Ранняя проверка типов (type checking)
- Выдача более точных ошибок на ранней стадии

**С генератором парсера:**
- Сложно интегрировать callback'и для семантического анализа
- Обычно требуется два прохода: парсинг → AST → семантический анализ

#### 5. Производительность

Рукописный парсер в Clang **оптимизирован для скорости**:

- Прямое управление потоком выполнения без overhead от автоматически сгенерированных таблиц
- Инлайнинг критических функций
- Отсутствие косвенных вызовов через таблицы переходов
- Оптимизация для типичных случаев (fast path)

**Сравнение:**
- LALR парсеры используют таблицы переходов (медленнее из-за промахов кэша)
- Рекурсивный нисходящий парсер — это просто обычный C++ код, который компилятор хорошо оптимизирует

#### 6. Гибкость и возможность экспериментов

**Рукописный парсер позволяет:**
- Легко добавлять экспериментальные фичи (например, concepts в C++20)
- Поддерживать расширения языка (GNU extensions, MSVC extensions)
- Реализовать режимы совместимости с разными компиляторами
- Быстро прототипировать новые возможности языка

**С генератором парсера:**
- Нужно изменять грамматику в специальном формате
- Регенерация парсера может занимать время
- Сложнее поддерживать условную компиляцию и расширения

#### 7. Простота отладки и сопровождения

**Преимущества рукописного кода:**
- Код парсера — это обычный C++, который можно читать и отлаживать
- Можно поставить breakpoint и пройтись по коду
- Легче понять, что происходит при ошибке
- Проще для новых разработчиков

**Генераторы парсеров:**
- Создают тысячи строк автоматически сгенерированного кода
- Сложно отлаживать (нужно понимать работу генератора)
- При ошибках в грамматике получаются конфликты shift/reduce, которые сложно разрешать

#### 8. Исторический опыт: урок GCC

**История GCC:**
- До начала 2000-х GCC использовал Bison (LALR генератор)
- Столкнулись с проблемами при парсинге C++
- Переписали на рукописный рекурсивный нисходящий парсер
- Это значительно улучшило качество диагностики и восстановление после ошибок

**Вывод команды Clang:**
Учитывая опыт GCC, команда Clang с самого начала выбрала рукописный парсер, избежав проблем, с которыми столкнулся GCC.

### Альтернативы и почему они не подходят

| Подход | Проблема для C++ |
|--------|------------------|
| **LALR (Bison/Yacc)** | Не может обработать контекстно-зависимую грамматику C++, плохое восстановление после ошибок |
| **LR(1)** | Огромные таблицы парсера, всё ещё не решает проблему контекстной зависимости |
| **GLR (Generalized LR)** | Слишком медленный для production компилятора, сложность в реализации |
| **PEG (Parsing Expression Grammar)** | Проблемы с левой рекурсией, сложность с восстановлением после ошибок |
| **ANTLR** | Дополнительная зависимость, меньше контроля над процессом парсинга |

### Архитектура парсера Clang

**Основные компоненты:**
```
Preprocessor → производит → Token Stream
                              ↓
                           Parser (Recursive Descent)
                              ↓
                           Sema (Semantic Analysis)
                              ↓
                           AST (Abstract Syntax Tree)
```

**Расположение в коде:** `clang/lib/Parse/Parser.cpp`

### Вывод

Рукописный рекурсивный нисходящий парсер — это не просто выбор по привычке, а **обоснованное инженерное решение**, продиктованное:
1. Спецификой языка C++ (контекстная зависимость)
2. Требованиями к качеству диагностики
3. Необходимостью интеграции с семантическим анализом
4. Соображениями производительности
5. Историческим опытом индустрии (GCC)

## 2. Какие языки умеет компилировать clang

**Языки и фреймворки:**
- C (все версии)
- C++
- Objective-C
- Objective-C++
- OpenMP
- OpenCL
- RenderScript
- CUDA
- SYCL
- HIP

**Стандарты C:**
- K&R C
- ANSI C89
- ISO C90
- C94 (C89+AMD1)
- C99 (+TC1, TC2, TC3)
- C11
- C17
- C23
- C2y

**Стандарты C++:**
- C++98
- C++03
- C++11
- C++14
- C++17 (полная поддержка в Clang 17+)
- C++20 (большинство функций реализовано)
- C++23 (начальная поддержка)
- C++26 (в разработке)

**По умолчанию:** Clang 16 и новее компилирует C++ код по стандарту C++17

**Стандарты Objective-C:**
- ObjC 1
- ObjC 2
- ObjC 2.1
- Плюс варианты в зависимости от базового языка

**Стандарты OpenCL:**
- OpenCL C 1.0, 1.1, 1.2, 2.0, 3.0
- C++ for OpenCL 1.0 и 2021

## 3. Зачем тогда понадобился LLVM, чем он отличается от JVM

**LLVM vs JVM - ключевые различия:**

### Архитектура
- **LLVM:** Низкоуровневая, регистровая виртуальная машина (register-based VM)
- **JVM:** Высокоуровневая, стековая виртуальная машина (stack-based VM), которая загружает значения на стек и вычисляет значения оттуда

### Уровень абстракции
- **LLVM:** Более низкий уровень, чем типичные VM вроде JVM и CLR
  - Не предоставляет сборщик мусора (только хуки для него)
  - Нет встроенного понятия объектов или виртуальных вызовов методов
  - Bitcode ближе к машинному коду, но не привязан к конкретной архитектуре

- **JVM:** Предоставляет высокоуровневую инфраструктуру
  - Встроенный сборщик мусора
  - Понятие объектов и виртуальных вызовов методов
  - Более высокий уровень для языковой совместимости

### Подход к компиляции
- **LLVM:** Преимущественно AOT (ahead-of-time) компиляция
  - Генерирует специфичные для архитектуры исполняемые файлы заранее
  - Не нужен во время выполнения
  - Но также поддерживает JIT (just-in-time) компиляцию на основе IR (например, для REPL в Julia)

- **JVM:** Преимущественно JIT (just-in-time) компиляция
  - Компилирует байткод во время выполнения

### Цель и философия дизайна
- **LLVM:** Спроектирован для абстрагирования от базового железа и четкого разделения между:
  - Backend компилятора (генерация машинного кода)
  - Frontend компилятора (парсинг и т.д.)
  - IR (Intermediate Representation) разработан как портативный ассемблер

- **JVM:** Спроектирован для:
  - Распространения байткода по сети
  - Интерпретации в локальном компьютере через виртуальную машину
  - Байткод стековый, что обычно делает его меньше по размеру

### Зачем понадобился LLVM?
LLVM создан как универсальная инфраструктура компилятора, которая позволяет:
1. Писать один frontend для языка, который работает на многих архитектурах
2. Применять оптимизации на уровне IR, не зависящие от конкретного языка или архитектуры
3. Получать производительность нативного кода (в отличие от JVM)
4. Использовать в статических компиляторах (в отличие от JVM, которая ориентирована на рантайм)

**Оба** поддерживают множество языков программирования через промежуточные представления, но служат разным целям в ландшафте компиляторной инфраструктуры.
