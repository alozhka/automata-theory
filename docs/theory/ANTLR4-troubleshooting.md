# ANTLR4: Проблемы в грамматиках выражений

## 1. Учёт приоритета операторов

### Проблема
Без явного указания приоритета операторы выполняются в неправильном порядке:
```antlr
// НЕПРАВИЛЬНО
expr: expr '+' expr | expr '*' expr | NUMBER;
```
Выражение `2 + 3 * 4` может разобраться как `(2 + 3) * 4 = 20` вместо `2 + (3 * 4) = 14`.

### Диагностика
- Предупреждение ANTLR: "Multiple alternative could match"
- Неверные результаты вычисления выражений
- Проверка дерева разбора: `grun Grammar expr -tree`

### Решение
Использовать уровни правил или встроенный механизм приоритета ANTLR4:

```antlr
// Вариант 1: Иерархия правил (явный приоритет)
expr:       term (( '+' | '-' ) term)* ;
term:       factor (( '*' | '/' ) factor)* ;
factor:     NUMBER | '(' expr ')' ;

// Вариант 2: Прямая левая рекурсия (ANTLR4 автоматически определяет приоритет)
expr:       expr '*' expr       // высший приоритет (первое правило)
    |       expr '+' expr       // низший приоритет
    |       NUMBER
    |       '(' expr ')'
    ;
```

---

## 2. Левая и правая рекурсия

### Проблема

**Левая рекурсия** (старый ANTLR3 не поддерживал):
```antlr
expr: expr '+' NUMBER ;  // OK в ANTLR4
```

**Непрямая левая рекурсия** (всё ещё проблематична):
```antlr
expr: term ;
term: expr '+' NUMBER ;  // ОШИБКА: косвенная левая рекурсия
```

**Правая рекурсия** (работает, но может быть неэффективной):
```antlr
expr: NUMBER '+' expr ;  // OK, но стек может переполниться
```

### Диагностика
- ANTLR4 выдаёт ошибку: "The following sets of rules are mutually left-recursive"
- Stack overflow при глубокой правой рекурсии

### Решение
```antlr
// Используйте прямую левую рекурсию (ANTLR4 преобразует автоматически)
expr: expr '+' NUMBER   // OK
    | NUMBER
    ;

// Для косвенной рекурсии - встраивайте правила
expr: expr '+' NUMBER | NUMBER ;  // вместо отдельного term
```

---

## 3. Левоассоциативные операции

### Проблема
Операторы типа `-`, `/` должны выполняться слева направо: `10 - 3 - 2 = (10 - 3) - 2 = 5`, а не `10 - (3 - 2) = 9`.

### Диагностика
```antlr
// НЕПРАВИЛЬНО: правоассоциативно
expr: NUMBER '-' expr | NUMBER ;
```
Тест: `10 - 3 - 2` даст неверный результат.

### Решение
ANTLR4 автоматически делает левую рекурсию левоассоциативной:
```antlr
// ПРАВИЛЬНО: левоассоциативно
expr: expr '-' expr     // автоматически (expr - expr) - expr
    | expr '/' expr
    | NUMBER
    ;
```

Альтернатива - EBNF нотация:
```antlr
expr: NUMBER ( '-' NUMBER )* ;  // явно левоассоциативно
```

---

## 4. Правоассоциативные операторы

### Проблема
Операторы типа `^` (степень) должны выполняться справа налево: `2 ^ 3 ^ 2 = 2 ^ (3 ^ 2) = 512`.

### Диагностика
```antlr
// НЕПРАВИЛЬНО для степени
expr: expr '^' expr | NUMBER ;  // даст левоассоциативность
```

### Решение
Использовать правую рекурсию с тегом `<assoc=right>`:
```antlr
expr: <assoc=right> expr '^' expr   // ПРАВИЛЬНО
    | expr '*' expr                 // левоассоциативно
    | expr '+' expr                 // левоассоциативно
    | NUMBER
    ;
```

Или отдельное правило:
```antlr
expr:       term ( '+' term )* ;
term:       power ( '*' power )* ;
power:      atom ( '^' power )? ;   // правая рекурсия
atom:       NUMBER | '(' expr ')' ;
```

---

## 5. Неоднозначность правил

### Проблема
Конструкции вроде `foo` или `foo()` могут быть переменной или вызовом функции:
```antlr
// НЕОДНОЗНАЧНО
expr: ID            // переменная
    | ID '(' ')'    // функция без параметров
    ;
```
ANTLR разрешит через первое правило, второе никогда не сработает.

### Диагностика
- Предупреждения ANTLR: "Decision can match input using multiple alternatives"
- Используйте `-diagnostics` флаг при генерации
- Визуализация: `grun Grammar startRule -gui`

### Решение

**Вариант 1**: Объединить альтернативы
```antlr
expr: ID ( '(' exprList? ')' )?     // переменная или вызов
    | NUMBER
    ;
```

**Вариант 2**: Семантические предикаты
```antlr
expr: {isFunction()}? ID '(' ')'    // вызов функции
    | ID                             // переменная
    ;
```

**Вариант 3**: Постобработка в посетителе (visitor)
```csharp
// Грамматика
primary: ID ( '(' exprList? ')' )? ;

// C# код
public override Result VisitPrimary(PrimaryContext ctx) {
    if (ctx.children.Count == 1) {
        return new Variable(ctx.ID().GetText());
    } else {
        return new FunctionCall(ctx.ID().GetText(), VisitExprList(ctx.exprList()));
    }
}
```

---

## Общие рекомендации

1. **Тестирование**: Используйте `grun` для визуализации дерева разбора
   ```bash
   antlr4 Expr.g4
   javac Expr*.java
   grun Expr expr -gui
   # Введите: 2 + 3 * 4
   ```

2. **Отладка**: Включите диагностику
   ```bash
   antlr4 -diagnostics Expr.g4
   ```

3. **Приоритет**: Первые альтернативы имеют высший приоритет в прямой левой рекурсии

4. **Тестовые случаи**: Создайте набор тестов для проверки приоритета и ассоциативности
   ```csharp
   [Test]
   public void TestPrecedence() {
       Assert.AreEqual(14, Evaluate("2 + 3 * 4"));
       Assert.AreEqual(20, Evaluate("(2 + 3) * 4"));
   }

   [Test]
   public void TestAssociativity() {
       Assert.AreEqual(5, Evaluate("10 - 3 - 2"));  // левоассоциативность
       Assert.AreEqual(512, Evaluate("2 ^ 3 ^ 2")); // правоассоциативность
   }
   ```

5. **Документация**: [ANTLR4 Documentation](https://github.com/antlr/antlr4/blob/master/doc/index.md)